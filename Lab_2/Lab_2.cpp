/*
В программе циклически осуществляется вывод запроса пользователю на выбор действия и выполнение выбранного действия. Доступные действия: «1. Создать файл с исходными данными», «2. Загрузить исходные данные», «3. Вывести исходные данные», «4. Обработать данные», «5. Завершить работу с программой». Каждое действие выбирается пользователем путем однократного нажатия на соответствующую цифровую клавишу.
При выборе действия «1» у пользователя запрашивается: имя двоичного файла, в который будет сохраняться задаваемый пользователем массив; кол-во элементов массива; значения самих элементов. Результат открытия файлового потока должен проверяться. В случае ошибки, имя файла должно запрашиваться повторно. Также необходимо проверять на существование по указанному пути файла с указанным именем и, в случае его наличия, выдавать пользователю запрос на перезапись этого файла. Такую проверку можно реализовать средствами потока. Корректность вводимых пользователем числовых значений количества элементов и самих элементов должна проверяться. В случае некорректности, соответствующее значение должно запрашиваться повторно. Имя файла можно запрашивать в последнюю очередь. Это позволит (при дополнительной программной реализации такой возможности) пользователю отказаться от записи данных в файл, но при этом сформированный массив останется в памяти и будет доступен для дальнейшей обработки.
При выборе действия «2» у пользователя должен запрашиваться ввод с клавиатуры имени двоичного файла, из которого будут загружаться элементы массива. Результат открытия файлового потока должен проверяться. При неуспешном открытии потока имя файла должно запрашиваться повторно. При успешной загрузке данных, исходный массив должен сразу выводиться на экран. Должны присутствовать простейшие проверки целостности данных, загружаемых из файла.
Память под хранение элементов массива должна выделяться динамически с помощью оператора new (освобождаться – с помощью delete), размер выделяемой памяти должен определяться программой автоматически по содержимому файла (а не вводиться пользователем с клавиатуры). Результат выделения памяти должен проверяться. При неуспешном выделении должно выводиться соответствующее сообщение.
Вывод результатов на экран – форматированный. Если выводится массив, то в первой строке – порядковые номера элементов, а строго под ними – значения соответствующих элементов; в начале строки с номерами – слово «Номера:», в начале строки с элементами – слово «Элементы:».
При выборе действия «3» выполняется вывод ранее созданного (в результате выполнения действия «1») или загруженного из файла в память (в результате выполнения действия «2») исходного массива на экран.
При выборе действия «4» выполняется обработка ранее созданного или загруженного из файла в память исходного массива и вывод результатов обработки на экран.
Выбор пользователем действий «3» и «4» никогда не должен приводить к возникновению необработанных ошибок. Повторное выполнение действий «1» и «2» не должно приводить к утечке памяти.
Для возврата к выбору следующего действия (т.е. в меню) после выполнения действий «1-4» должно ожидаться нажатие пользователем любой клавиши с выводом соответствующей подсказки. Меню всегда должно выводиться в чистом окне консоли. После выбора пользователем нужного действия (пункта меню) консоль также должна очищаться.
В любом месте программы продемонстрировать применение адресной арифметики для обращения к элементам массива.
При выборе действия «5» работа программы завершается.
В программе должны присутствовать все необходимые подписи, приглашения к вводу и подсказки для пользователя на русском языке.
Если по Вашему варианту задания №6 дано 2 исходных массива, то в целях упрощения задачи можно свести условие задачи к одному массиву. Например: «заменить в первом массиве все отрицательные элементы на максимальный элемент из второго» → «заменить в массиве все отрицательные элементы на максимальный».
*/

/*
Задание 6
Дан массив P1, ... , P40.
Заменить Pmax и Pmin на среднее арифметическое всего ряда.
*/

#include <iostream>
#include <windows.h>
#include <errno.h>
#include <sstream>
#include <algorithm>
#include <conio.h>
#include <fstream>
#include <iomanip>
#include <limits>

using namespace std;

// Заметки для пояснения:
	// 1. "/////..." - должно быть исправлено (доработано), "/////// ++++++..." - сделана работа над ошибками

int main()
{
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);
	cout.imbue(locale("russian_russia"));

	// Тип данных для вводимых в последовательность значений
	typedef double elemType;
	typedef size_t control;

	// Переменные для алгоритма перемещения по меню и работы с вводом имени файла
	char action;
	string temp, path;
	bool ret = false; // ret = "return" - флаг для возврата в начало меню
	elemType num;
	size_t i = 0;

	// Динамический массив
	elemType* arr = nullptr;
	control size = 0; 
	
	// Переменные для вывода полученного в ходе чтения массива или обработанного массива 
	size_t max_order, max_number; // max_order - длина максимального номера последнего значения (если оно есть)  
								  // max_number - максимальная длина среди всех значений массив

	// Переменные для работы с файловым потоком ввода и вывода соответственно
	fstream file;

	do
	{
		ret = false;
		cout << "Выберите действие:\n"
			<< "1. Ввести массив с клавиатуры и сохранить его в файл\n"
			<< "2. Загрузить массив из файла\n"
			<< "3. Вывести массив на экран\n"
			<< "4. Обработать массив\n"
			<< "5. Завершить работу с программой" << endl;
		action = _getch();

		switch (action)
		{

		// 1. Создание файла с исходными данными
		case '1':
			while (true)
			{
				system("cls");

				long long int size_default;
				cin.ignore(cin.rdbuf()->in_avail());
				cout << "Введите количество значений, которые вы хотите записать ('*' для возврата в меню): ";
				if (cin.peek() == '*' && cin.rdbuf()->in_avail() == 2)
				{
					ret = true;
					break;
				}

				cin >> size_default;
				if (cin.peek() != '\n' || size_default < 1)
				{
					cout << "Введено некорректное значение, попробуйте ещё раз!\n"
						<< "Нажмите любую клавишу для продолжения работы" << endl;
					_getch();
					cin.clear();
					continue;
				}

				if (arr)
					delete[] arr;
				size = size_default;
				arr = new (nothrow) elemType[size];
				if (arr == nullptr)
				{
					cout << "Ошибка выделения памяти!\n";
					continue;
				}
				break;
			}

			if (ret)
			{
				system("cls");
				continue;
			}

			i = 0;

			cout << "Поочерёдно вводите значения ('*' для возврата в меню):\n";
			while (i < size) 
			{
				cin.ignore(cin.rdbuf()->in_avail());
				cout << i + 1 << "-ое число: ";
				if (cin.peek() == '*' && cin.rdbuf()->in_avail() == 2)
				{
					ret = true;
					break;
				}
				cin >> num;
				if (cin.peek() != '\n')
				{
					cout << "Повторите попытку ввода этого числа, потом продолжайте!" << endl;
					cin.clear();
					continue;
				}
				arr[i] = num;
				i++;
			}

			if (ret)
			{
				delete[] arr;
				arr = nullptr;
				system("cls");
				break;
			}

			// Предварительная очистка буфера потока ввода перед запросом имени файла
			while (true)
			{
				cin.ignore(cin.rdbuf()->in_avail());
				cout << "Введите название двоичного файла ('*' для возврата в меню): ";
				if (cin.peek() == '*' && cin.rdbuf()->in_avail() == 2)
				{
					ret = true;
					break;
				}
				getline(cin, path);

				file.open(path, ios::in | ios::binary);
				if (file.is_open())
				{
					cout << "Файл уже существует! Желаете его перезаписать ('y' - да, 'n' - нет, '*' - возврат в меню): ";
					do
						temp = _getch();
					while (temp != "y" && temp != "n" && temp != "*");

					if (temp == "*")
						break;
					
					if (temp == "n")
					{
						file.close();
						endl(cout);
						continue;
					}
				}				
				file.close();

				file.open(path, ios::binary | ios::out);
				if (!file.is_open())
				{
					file.close();
					cout << "Не удалось открыть файл - \'" << path << '\'' << endl;
					cout << "Код ошибки: " << _errno() << endl;
					perror("Описание ошибки: ");
					endl(cout);
					continue;
				}
				file.write((char*)&size, sizeof(size));
				file.write((char*)arr, size * sizeof(elemType));
				if (file.fail())
				{
					file.close();
					cout << "Не удалось записать данные!" << endl
						<< "Нажмите любую клавишу для продолжения!";
					_getch();
					system("cls");
					continue;
				}
				break;
			}

			file.close();
			system("cls");
			continue;

		// 2. Загружаем данные из существующего файла
		case '2':
			system("cls");
			do
			{
				cout << "Введите название двоичного файла ('*' для возврата в меню): ";
				cin.ignore(cin.rdbuf()->in_avail());
				if (cin.peek() == '*' && cin.rdbuf()->in_avail() == 2)
				{
					ret = true;
					break;
				}
				getline(cin, path);

				// Пытаемся открыть поток
				file.open(path, ios::binary | ios::in | ios::ate);
				if (!file.is_open())
				{
					cout << "Не удалось открыть файл - \'" << path << '\'' << endl;
					continue;
				}

				///////////////////////////////////////////// Не понятно, для чего вводить дополнительный флаг и, если действительно надо, то как это реализовать

				// Получаем размер файла
				control size_default = file.tellg();
				if (!size_default)
				{
					file.close();
					cout << "Файл пуст!" << endl;
					continue; 
				}

				// Проверяем, достаточен ли размер файла для того, чтобы из него можно было считать хотя бы контрольное значение (кол-во элементов)
				if (size_default < sizeof(size))
				{
					file.close();
					cout << "Файл повреждён! (контрольное значение)" << endl;
					continue;
				}
				size_default -= sizeof(size);

				// Проверяем, что размер части содержимого файла, занимаемой самой последовательностью, кратен размеру 1 элемента
				if (size_default % sizeof(elemType))
				{
					file.close();
					cout << "Файл повреждён! (размер части файла, занимаемой последовательностью)" << endl;
					continue;
				}
				size_default /= sizeof(elemType);

				// Считываем из файла в соответствующую переменную контрольное значение
				file.seekg(0);
				file.read((char*)&size_default, sizeof(size_default));
				size = size_default;

				try
				{
					arr = new elemType[size];
				}
				catch (...)
				{
					file.close();
					cout << "Ошибка выделения памяти!\n"
						<< "Нажмите любую клавишу для продолжения: " << endl;
					_getch();
					continue;
				}
				break;
			} while (true);
			
			if (ret)
			{
				system("cls");
				continue;
			}

			file.read((char*)arr, size * sizeof(elemType));
			file.close();

			// 3. Выводим загруженные данные в консоль
		case '3':
			system("cls");

			if (arr == nullptr)
			{
				cout << "Массив отсутствует!\n"
					<< "Нажмите любую клавишу для продолжения работы программы: ";
				_getch();
				system("cls");
				continue;
			}

			// Находим: 1. Максимальную длину между наибольшим порядковым номером числа и строки "Номер" (5)
			//			2. Максимальную длину прочитанных значений
			max_order = max(to_string(size).length(), 5),
			max_number = 8;

			for (size_t i = 0; i < size; i++)
			{
				ostringstream oss;
				oss << arr[i];
				size_t len = oss.tellp();
				if (len > max_number) max_number = len;
			}

			// Выводим массив значений
			cout << setw(max_order) << "Номер" << " | " << setw(max_number) << "Значение" << endl;
			for (size_t i = 0; i < size; i++)
				cout << setw(max_order) << i + 1 << " | " << setw(max_number) << arr[i] << endl;

			cout << "Введите любую клавишу для продолжения: ";
			_getch();
			system("cls");
			break;

			// 4. Обрабатываем загруженные данные
		case '4':
			system("cls");
			if (arr == nullptr)
			{
				cout << "Массив отсутствует!\n"
					<< "Нажмите любую клавишу для продолжения работы программы: ";
				_getch();
				system("cls");
				break;
			}

			{
				elemType mx = (numeric_limits<elemType>::min)(),
					mn = (numeric_limits<elemType>::max)(),
					s = 0,
					avg;
			
			// Ищем максимальное и минимальное число и сумму всей последовательности массива
			for (size_t i = 0; i < size; i++)
			{
				if (arr[i] > mx) mx = arr[i];
				if (arr[i] < mn) mn = arr[i];
				s += arr[i];
			}

			avg = s / size;
			cout << "Файл содержит " << size << " значений(-ия, -ие)" << endl
				<< "Максимальное значение = " << mx << endl
				<< "Минимальное значение = " << mn << endl
				<< "Среднее арифметическое ряда = " << avg << endl;

			elemType* result = new (nothrow) elemType[size];
			if (!result)
			{
				cout << "Произошла ошибка выделения памяти под массив обработанной последовательности!";
				continue;
			}


			// Заменяем Pmax и Pmin на avg
			for (size_t i = 0; i < size; result[i] = arr[i], i++)
			for (size_t i = 0; i < size; i++)
			{
				if (arr[i] == mx) result[i] = avg;
				if (arr[i] == mn) result[i] = avg;
			}

			// Находим: 1. Максимальную длину между наибольшим порядковым номером числа и строки "Номер" (5)
			//			2. Максимальную длину прочитанных значений
			max_order = max(to_string(size).length(), 5),
			max_number = 8;

			for (size_t i = 0; i < size; i++)
			{
				ostringstream oss;
				oss << result[i];
				size_t len = oss.tellp();
				if (len > max_number) max_number = len;
			}

			// Выводим массив значений
			cout << setw(max_order) << "Номер" << " | " << setw(max_number) << "Значение" << endl;
			for (size_t i = 0; i < size; i++)
				cout << setw(max_order) << i + 1 << " | " << setw(max_number) << result[i] << endl;
			delete[] result;
			break;
			}
			// 5. Завершаем работу программы
		case '5':
			system("cls");
			delete[] arr;
			exit(0);
			break;

			// Обрабатываем исключение ввода действия, не удовлетворяющего меню
		default:
			system("cls");
			cout << "Введено некорректное значение!\n";
			break;
		}

	} while (true);

	return 0;
}